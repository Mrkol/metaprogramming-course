Задача 2. Slice-n-dice
========================

## Подготовка

Обязательно решите [первую задачу](/tasks/span.md).

Вспомните, как работает наследование в языке C++.
Обязательно ли оно подразумевает использование ООП подхода?

## Задача

### Slice

В данной задаче вам предстоит написать более общую версию `std::span`: `Slice`, поддерживающий дополнительный шаблонный параметр stride -- размер шага при переходе к следующему элементу. Например,
```c++
    std::array<int, 10> data;
    std::iota(data.begin(), data.end(), 0);
    Slice<int, 5, 2> even_elements{data};
```
Здесь содержимое `even_elements` должно быть `0, 2, 4, 6, 8`. Также ваша имплементация должна поддерживать рантайм значение как обоих параметров, так и любого одного из них, при подстановке в шаблон `std::dynamic_extent` и `dynamic_stride` соответственно.

### Интерфейс Slice

Требования к шаблону `Slice` -- повторение интерфейса [`std::span`](https://en.cppreference.com/w/cpp/container/span), кроме следующих исключений:
* `size_bytes`
* `as_bytes`
* `as_writable_bytes`
* `subspan`
Эти методы подразумевают `stride == 1`, поэтому пока что мы будем их игнорировать. Также пока что игнорируйте раздел "Helper templates". Наконец, конструкторы `std::span` -- достаточно тонкая наука, поэтому предлагается не повторять их один к одному с cppreference, а написать свои с нуля так, чтобы тесты проходили.
Далее, нам потребуется некоторое количество дополнений связанных с параметром `stride`:
* Методы `Skip`, позволяющие поменять `stride`
* Методы `DropFirst`, откидывающие несколько первых элементов
* Методы `DropLast`, откидывающие несколько последних элементов
* Модификация конструктора от итератора и размера, принимающая ещё и `stride`
Обратите внимание, что мы не требуем метода `Subslice`, аналогичного `subspan`. Попытка написать такой метод, учитывающий все комбинации рантайм и компайлтайм параметров, ведёт к комбинаторному взрыву, поэтому вместо него мы предоставляем более элементарные методы `First`, `Last`, `DropFirst`, `DropLast` и `Stride`. Для каждого из них создайте две перегрузки: с шаблонным параметром и с обычным.

Заметьте, что `const Slice<T>` и `Slice<const T>` -- не одно и то же! Первое запрещает менять текущую переменную типа `Slice`, второе запрещает менять данные, на которые указывает текущая переменная.

Ещё мы требуем, чтобы `Slice` со статическими параметрами неявно кастился к аналогичному слайсу с динамическими параметрами (и оба одновременно, и только один по-отдельности). Каст `Slice<T>` к `Slice<const T>` также должен быть неявным.

Также обязательное требование -- размер каждой специализации `Slice` должен быть минимальным из возможных. То есть нельзя хранить данные об `extent` и `stride` в рантайме, если они известны в компайлтайме. Подумайте как добиться этого не решив всю задачу заново 4 раза. Возможно вам поможет наследование? Не бойтесь использовать всю силу C++ и хоть полностью менять шаблон решения. Главное -- пройти тесты.

Не засоряйте глобальный неймспейс вспомогательными шаблонами, помещайте их в отдельный `namespace`.

## Формальности

**Баллы:** 250

Шаблон `Slice` должнен быть доступен в глобальном неймспейсе при подключении заголовочного файла `Slice.hpp`. Обратите внимание, что создание дополнительных файлов и классов не возбраняется. `cpp` файлы в папке будут автоматически скомпилированы и прилинкованы к тестам, хоть в этой задаче они скорее всего и не пригодятся.

Код пушьте в ветку `slice` и делайте pull request в `master`.
