Задача 1. Разминка
========================

## Подготовка

Вспомните, что такое шаблоны, явные специализации (полные и частичные).

Вспомните, что шаблон `std::span` стандартной библиотеки используется как невладеющая ссылка на несколько подряд расположенных в памяти объектов.
Он служит "наибольшим общим знаменателем" между различными видами [contiguous контейнеров](https://en.cppreference.com/w/cpp/named_req/ContiguousContainer).
Используя его в качестве аргумента функции, вы позволяете пользователю передавать в вашу функцию и `std::vector` с произвольным аллокатором, и `std::array` любого размера, и различные обёртки вроде [`std::flat_map`](https://en.cppreference.com/w/cpp/header/flat_map), и даже контейнеры из других библиотек, коих на практике встречается великое множество.

Обратите внимание, что у `std::span` не один шаблонный аргумент, а два: тип элемента и размер.
Размер может быть задан как `std::dynamic_extent`, что означает "размер не известен во время компиляции, но будет известен в рантайме".

Вспомните или почитайте о том, что такое [user-defined deduction guides](https://en.cppreference.com/w/cpp/language/class_template_argument_deduction).

Некоторые операции над `std::span` могут быть некорректны. Например, конструирование `std::span<int, 1000>` от пустого `std::vector<int>`, потому что в нем нет тысячи элементов. Для проверки этого и других инвариантов в рантайме предлагается использовать макрос `MPC_VERIFY(cond, message)` из файла `"lib/assert.hpp"`. Специальный макрос используется для удобного покрытия тестами.

## Задача

Напишите свой собственный `std::span`.

Заметьте, что `const Span<T>` и `Span<const T>` -- не одно и то же! Первое запрещает менять текущую переменную типа `Span<T>`, второе запрещает менять данные типа `T`, на которые указывает `Span`.

Также обязательное требование -- размер каждой специализации `Span` должен быть минимальным из возможных.
То есть если размер `Span` известен во время компиляции, в соответствующей специализации не должно быть поля для хранения размера в рантайме.

В качестве итераторов для вашего класса используйте указатели.

Не забудьте проставить ассёрты на выходы за границы во всех методах.

Наконец, не забудьте ознакомиться с [тестами](/tests/span).

## Формальности

**Баллы:** 100

Шаблон `Span` должнен быть доступен в глобальном неймспейсе при подключении заголовочного файла `Span.hpp`.

Код пушьте в ветку `span` и делайте pull request в `master`.
